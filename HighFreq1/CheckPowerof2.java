/*
O(1) Check Power of 2
Using O(1) time to check whether an integer n is a power of 2.
Example
For n=4, return true;
For n=5, return false;
Challenge
O(1) time
*/
/*
bit manipulation
1的个数只能有1个才是power of 2
注意Integer.MIN_VALUE, 这个只有一个1, 但是是false
note: int 32 bits (-2147483648, 2147483647) (-2^31, 2^31 - 1) (0后面31个1 = 2^31 - 1)
Integer.MIN_VALUE = -2147483648 二进制表示 = 1000...0 (31个0, 1是符号位)
二进制原码最大 0111...1 (0后面31个1) = 2^31 - 1 = 2147483647
二进制原码最小 1111...1 (32个1) = - (2^31 - 1) = -2147483647
正0和负0: 000...0 = 1000...0 = 0
二进制原码表示时, 范围是-2147483647~0, 0~2147483647, 因为有两个零的存在, 所以不同的数值个数一共只有2^32 - 1个, 比16位二进制能够提供的2^32个编码少1个

但是计算机中采用二进制补码存储数据.
正数编码不变, 从000...0到0111...1依旧表示0到2147483647
负数需要把除符号位以后的部分取反加1, 即
-2147483647 = 11111111 11111111 11111111 11111111.
它的反码为: 10000000 00000000 00000000 00000000. 
它的补码为: 10000000 00000000 00000000 00000001. 
再来看原码的正0和负0: 
00000000 00000000 00000000 00000000 
10000000 00000000 00000000 00000000
补码表示中, 
前者的补码 00000000 00000000 00000000 00000000 
后者经过非符号位取反加1后, 同样变成了 00000000 00000000 00000000 00000000 
正0和负0在补码系统中的编码是一样的, 
32位二进制数可以表示2^32个编码, 而在补码中零的编码只有一个, 也就是补码中会比原码多一个编码出来, 
这个编码就是 10000000 00000000 00000000 00000000
因为任何一个原码都不可能在转成补码时变成10000000 00000000 00000000 00000000
所以, 人为规定10000000 00000000 00000000 00000000这个补码编码为-2147483648
补码系统中, int 32 bits (-2147483648, 2147483647)
实际上, 二进制的最小数确实是111...1, 只是二进制补码的最小值才是1000...0, 而补码的111...1是二进制值的-1
*/
public class CheckPowSol {
	public static boolean checkPowerOf21(int n) {
		if (n <= 0) {
			return false;
		}

		if ((n & (n - 1)) == 0) {
			return true;
		} else return false;
	}
	
	public static boolean checkPowerOf22(int n) {
		int cnt = 0;
		for (int i = 0; i < 31; i++) {
			if (((n >> i) & 1) == 1) {
				cnt++;
			} 
		}
		if (cnt == 1) {
			return true;
		}
		return false;
	}
	
	public static void main(String[] args) {
		System.out.print(checkPowerOf21(Integer.MIN_VALUE));
	}
}
